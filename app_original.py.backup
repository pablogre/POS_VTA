# app.py - Sistema de Punto de Venta Argentina con Flask, MySQL y ARCA - VERSI√ìN LIMPIA

from flask import Flask, render_template, request, jsonify, redirect, url_for, session, flash
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import Numeric, or_, and_  # ‚Üê IMPORTAR AQU√ç
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta
import mysql.connector
from decimal import Decimal
import os
import requests
import xml.etree.ElementTree as ET
from zeep import Client
from zeep.wsse import BinarySignature
import base64
import hashlib
from cryptography import x509
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding
import json

app = Flask(__name__)
app.config['SECRET_KEY'] = 'tu_clave_secreta_aqui'

# Intentar cargar configuraci√≥n local, si no existe usar por defecto
try:
    from config_local import Config, ARCAConfig
    app.config.from_object(Config)
    ARCA_CONFIG = ARCAConfig()
except ImportError:
    # Configuraci√≥n por defecto si no existe config_local.py
    app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://pos_user:pos_password@localhost/pos_argentina'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    
    class DefaultARCAConfig:
        CUIT = '20203852100'
        PUNTO_VENTA = 3
        CERT_PATH = 'certificados/certificado.crt'
        KEY_PATH = 'certificados/private.key'
        USE_HOMOLOGACION = False
        
        @property
        def WSAA_URL(self):
            return 'https://wsaahomo.afip.gov.ar/ws/services/LoginCms' if self.USE_HOMOLOGACION else 'https://wsaa.afip.gov.ar/ws/services/LoginCms'
        
        @property
        def WSFEv1_URL(self):
            return 'https://wswhomo.afip.gov.ar/wsfev1/service.asmx?WSDL' if self.USE_HOMOLOGACION else 'https://servicios1.afip.gov.ar/wsfev1/service.asmx?WSDL'
        
        TOKEN_CACHE_FILE = 'cache/token_arca.json'
    
    ARCA_CONFIG = DefaultARCAConfig()

db = SQLAlchemy(app)

# Modelos de Base de Datos
class Usuario(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    nombre = db.Column(db.String(100), nullable=False)
    rol = db.Column(db.String(50), default='vendedor')
    activo = db.Column(db.Boolean, default=True)

class Cliente(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    documento = db.Column(db.String(20))
    tipo_documento = db.Column(db.String(10))  # DNI, CUIT, etc.
    email = db.Column(db.String(100))
    telefono = db.Column(db.String(20))
    direccion = db.Column(db.Text)
    condicion_iva = db.Column(db.String(50))  # Responsable Inscripto, Monotributista, etc.

class Producto(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    codigo = db.Column(db.String(50), unique=True, nullable=False)
    nombre = db.Column(db.String(200), nullable=False)
    descripcion = db.Column(db.Text)
    precio = db.Column(Numeric(10, 2), nullable=False)
    stock = db.Column(db.Integer, default=0)
    categoria = db.Column(db.String(100))
    iva = db.Column(Numeric(5, 2), default=21.00)
    activo = db.Column(db.Boolean, default=True)

class Factura(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    numero = db.Column(db.String(50), unique=True)
    tipo_comprobante = db.Column(db.String(10))  # FA, FB, FC, etc.
    punto_venta = db.Column(db.Integer)
    fecha = db.Column(db.DateTime, default=datetime.utcnow)
    cliente_id = db.Column(db.Integer, db.ForeignKey('cliente.id'))
    usuario_id = db.Column(db.Integer, db.ForeignKey('usuario.id'))
    subtotal = db.Column(Numeric(10, 2))
    iva = db.Column(Numeric(10, 2))
    total = db.Column(Numeric(10, 2))
    estado = db.Column(db.String(20), default='pendiente')  # pendiente, autorizada, anulada
    cae = db.Column(db.String(50))  # C√≥digo de Autorizaci√≥n Electr√≥nico
    vto_cae = db.Column(db.Date)
    
    cliente = db.relationship('Cliente', backref='facturas')
    usuario = db.relationship('Usuario', backref='facturas')

class DetalleFactura(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    factura_id = db.Column(db.Integer, db.ForeignKey('factura.id'))
    producto_id = db.Column(db.Integer, db.ForeignKey('producto.id'))
    cantidad = db.Column(db.Integer, nullable=False)
    precio_unitario = db.Column(Numeric(10, 2), nullable=False)
    subtotal = db.Column(Numeric(10, 2), nullable=False)
    
    factura = db.relationship('Factura', backref='detalles')
    producto = db.relationship('Producto', backref='detalles_factura')

# Clase para manejo de ARCA/AFIP
# Clase para manejo de ARCA/AFIP - VERSI√ìN MEJOR# REEMPLAZAR TODA la clase ARCAClient en tu app.py por esta versi√≥n COMPLETA:
# Clase para manejo de ARCA/AFIP - VERSI√ìN SSL-FIXED
class ARCAClient:
    def __init__(self):
        self.config = ARCA_CONFIG
        self.token = None
        self.sign = None
        self.openssl_path = './openssl.exe'
        
        # Configurar SSL para AFIP
        self._configure_ssl()
        
        print(f"üîß AFIP Client Simple inicializado")
        print(f"   CUIT: {self.config.CUIT}")
        print(f"   Ambiente: {'HOMOLOGACI√ìN' if self.config.USE_HOMOLOGACION else 'PRODUCCI√ìN'}")
    
    def _configure_ssl(self):
        """Configurar SSL para compatibilidad con AFIP"""
        import ssl
        import urllib3
        
        # Configurar OpenSSL
        os.environ['OPENSSL_CONF'] = ''
        
        # Desactivar advertencias SSL
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # Configurar SSL global para permitir DH keys peque√±as
        ssl._create_default_https_context = ssl._create_unverified_context
    
    def _create_zeep_transport(self):
        """Crear transporte ZEEP con SSL personalizado"""
        from zeep.transports import Transport
        import ssl
        
        # Contexto SSL personalizado
        ctx = ssl.create_default_context()
        ctx.set_ciphers('DEFAULT@SECLEVEL=1')
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        
        return Transport(timeout=60)
    
    def verificar_openssl(self):
        """Verificar que OpenSSL est√© disponible"""
        try:
            import subprocess
            
            # PRIMERO: Probar OpenSSL local
            if os.path.exists('./openssl.exe'):
                try:
                    result = subprocess.run(['./openssl.exe', 'version'], 
                                          capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        print(f"‚úÖ OpenSSL local encontrado: {result.stdout.strip()}")
                        self.openssl_path = './openssl.exe'
                        return True
                except Exception as e:
                    print(f"‚ö†Ô∏è Error con OpenSSL local: {e}")
            
            # SEGUNDO: Probar ruta completa conocida
            ruta_conocida = r"C:\Program Files\OpenSSL-Win64\bin\openssl.exe"
            if os.path.exists(ruta_conocida):
                try:
                    result = subprocess.run([ruta_conocida, 'version'], 
                                          capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        print(f"‚úÖ OpenSSL encontrado en ruta completa: {result.stdout.strip()}")
                        self.openssl_path = ruta_conocida
                        return True
                except Exception as e:
                    print(f"‚ö†Ô∏è Error con ruta completa: {e}")
            
            # TERCERO: Probar comando directo
            try:
                result = subprocess.run(['openssl', 'version'], 
                                      capture_output=True, text=True, timeout=10)
                if result.returncode == 0:
                    print(f"‚úÖ OpenSSL encontrado en PATH: {result.stdout.strip()}")
                    self.openssl_path = 'openssl'
                    return True
            except Exception as e:
                print(f"‚ö†Ô∏è Error con comando directo: {e}")
            
            print("‚ùå OpenSSL no encontrado en ninguna ubicaci√≥n")
            return False
            
        except Exception as e:
            print(f"‚ùå Error verificando OpenSSL: {e}")
            return False
    
    def crear_tra(self):
        """Crear Ticket Request Access"""
        now = datetime.utcnow()
        expire = now + timedelta(hours=12)
        unique_id = int(now.timestamp())
        
        tra_xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<loginTicketRequest version="1.0">
    <header>
        <uniqueId>{unique_id}</uniqueId>
        <generationTime>{now.strftime('%Y-%m-%dT%H:%M:%S.000-00:00')}</generationTime>
        <expirationTime>{expire.strftime('%Y-%m-%dT%H:%M:%S.000-00:00')}</expirationTime>
    </header>
    <service>wsfe</service>
</loginTicketRequest>"""
        
        return tra_xml
    
    def firmar_tra_openssl(self, tra_xml):
        """Firmar TRA usando OpenSSL"""
        try:
            import tempfile
            import subprocess
            import base64
            
            print(f"üîê Firmando TRA con OpenSSL: {self.openssl_path}")
            
            # Crear archivos temporales
            with tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False) as tra_file:
                tra_file.write(tra_xml)
                tra_temp = tra_file.name
            
            with tempfile.NamedTemporaryFile(suffix='.cms', delete=False) as cms_file:
                cms_temp = cms_file.name
            
            # Comando OpenSSL
            cmd = [
                self.openssl_path, 'smime', '-sign',
                '-in', tra_temp,
                '-out', cms_temp,
                '-signer', self.config.CERT_PATH,
                '-inkey', self.config.KEY_PATH,
                '-outform', 'DER',
                '-nodetach'
            ]
            
            print(f"üìù Ejecutando firma...")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                print(f"‚ùå Error OpenSSL: {result.stderr}")
                raise Exception(f"Error OpenSSL: {result.stderr}")
            
            # Leer archivo firmado
            with open(cms_temp, 'rb') as f:
                cms_data = f.read()
            
            # Limpiar archivos temporales
            os.unlink(tra_temp)
            os.unlink(cms_temp)
            
            # Codificar en base64
            cms_b64 = base64.b64encode(cms_data).decode('utf-8')
            
            print("‚úÖ TRA firmado correctamente")
            return cms_b64
            
        except Exception as e:
            print(f"‚ùå Error firmando TRA: {e}")
            raise Exception(f"Error firmando TRA: {e}")
    
    def get_ticket_access(self):
        """Obtener ticket de acceso de WSAA"""
        try:
            print("üé´ Obteniendo ticket de acceso...")
            
            # Verificar certificados
            if not os.path.exists(self.config.CERT_PATH):
                raise Exception(f"Certificado no encontrado: {self.config.CERT_PATH}")
            
            if not os.path.exists(self.config.KEY_PATH):
                raise Exception(f"Clave privada no encontrada: {self.config.KEY_PATH}")
            
            # Verificar OpenSSL
            if not self.verificar_openssl():
                raise Exception("OpenSSL no disponible")
            
            # Crear y firmar TRA
            tra_xml = self.crear_tra()
            tra_firmado = self.firmar_tra_openssl(tra_xml)
            
            # Conectar con WSAA
            wsaa_url = 'https://wsaahomo.afip.gov.ar/ws/services/LoginCms?wsdl' if self.config.USE_HOMOLOGACION else 'https://wsaa.afip.gov.ar/ws/services/LoginCms?wsdl'
            
            print("üåê Conectando con WSAA...")
            from zeep import Client
            
            # Usar transporte SSL personalizado
            transport = self._create_zeep_transport()
            client = Client(wsaa_url, transport=transport)
            
            # Enviar solicitud
            response = client.service.loginCms(tra_firmado)
            
            if response:
                # Procesar respuesta XML
                import xml.etree.ElementTree as ET
                root = ET.fromstring(response)
                
                token_elem = root.find('.//token')
                sign_elem = root.find('.//sign')
                
                if token_elem is None or sign_elem is None:
                    raise Exception("Token o Sign no encontrados en respuesta")
                
                self.token = token_elem.text
                self.sign = sign_elem.text
                
                print("‚úÖ Ticket de acceso obtenido")
                return True
            else:
                raise Exception("Respuesta vac√≠a de WSAA")
                
        except Exception as e:
            print(f"‚ùå Error obteniendo ticket: {e}")
            return False
    
    def get_ultimo_comprobante(self, tipo_cbte):
        """Obtener √∫ltimo comprobante autorizado"""
        try:
            print(f"üìã Consultando √∫ltimo comprobante tipo {tipo_cbte}...")
            
            if not self.get_ticket_access():
                raise Exception("No se pudo obtener acceso a AFIP")
            
            wsfe_url = 'https://wswhomo.afip.gov.ar/wsfev1/service.asmx?WSDL' if self.config.USE_HOMOLOGACION else 'https://servicios1.afip.gov.ar/wsfev1/service.asmx?WSDL'
            
            from zeep import Client
            
            # Usar transporte SSL personalizado
            transport = self._create_zeep_transport()
            client = Client(wsfe_url, transport=transport)
            
            response = client.service.FECompUltimoAutorizado(
                Auth={
                    'Token': self.token,
                    'Sign': self.sign,
                    'Cuit': self.config.CUIT
                },
                PtoVta=self.config.PUNTO_VENTA,
                CbteTipo=tipo_cbte
            )
            
            if hasattr(response, 'Errors') and response.Errors:
                error_msg = response.Errors.Err[0].Msg
                raise Exception(f"Error AFIP: {error_msg}")
            
            ultimo_num = response.CbteNro
            print(f"‚úÖ √öltimo comprobante: {ultimo_num}")
            return ultimo_num
            
        except Exception as e:
            print(f"‚ùå Error consultando comprobante: {e}")
            raise Exception(f"Error al obtener √∫ltimo comprobante: {e}")
    
    def autorizar_comprobante(self, factura_data):
        """Autorizar comprobante en AFIP"""
        try:
            print(f"üìÑ Autorizando comprobante {factura_data['numero']}...")
            
            if not self.get_ticket_access():
                raise Exception("No se pudo obtener acceso a AFIP")
            
            wsfe_url = 'https://wswhomo.afip.gov.ar/wsfev1/service.asmx?WSDL' if self.config.USE_HOMOLOGACION else 'https://servicios1.afip.gov.ar/wsfev1/service.asmx?WSDL'
            
            from zeep import Client
            
            # Usar transporte SSL personalizado
            transport = self._create_zeep_transport()
            client = Client(wsfe_url, transport=transport)
            
            # Preparar datos
            cliente_cuit = factura_data.get('cliente_cuit', '0')
            if cliente_cuit and cliente_cuit != '0' and len(cliente_cuit) == 11:
                tipo_doc = 80  # CUIT
                nro_doc = int(cliente_cuit)
            else:
                tipo_doc = 99  # Sin identificar
                nro_doc = 0
            
            cbte_data = {
                'CbteTipo': factura_data['tipo_comprobante'],
                'PtoVta': self.config.PUNTO_VENTA,
                'Concepto': 1,  # Productos
                'DocTipo': tipo_doc,
                'DocNro': nro_doc,
                'CbteDesde': factura_data['numero'],
                'CbteHasta': factura_data['numero'],
                'CbteFch': factura_data['fecha'].strftime('%Y%m%d'),
                'ImpTotal': float(factura_data['total']),
                'ImpTotConc': 0,
                'ImpNeto': float(factura_data['subtotal']),
                'ImpOpEx': 0,
                'ImpIVA': float(factura_data['iva']),
                'ImpTrib': 0,
                'MonId': 'PES',
                'MonCotiz': 1
            }
            
            # Enviar solicitud
            response = client.service.FECAESolicitar(
                Auth={
                    'Token': self.token,
                    'Sign': self.sign,
                    'Cuit': self.config.CUIT
                },
                FeCAEReq={
                    'FeCabReq': {
                        'CantReg': 1,
                        'PtoVta': self.config.PUNTO_VENTA,
                        'CbteTipo': factura_data['tipo_comprobante']
                    },
                    'FeDetReq': {
                        'FECAEDetRequest': [cbte_data]
                    }
                }
            )
            
            # Verificar errores
            if hasattr(response, 'Errors') and response.Errors:
                error_msg = response.Errors.Err[0].Msg
                raise Exception(f"Error AFIP: {error_msg}")
            
            result = response.FeDetResp.FECAEDetResponse[0]
            
            if result.Resultado == 'A':
                print(f"‚úÖ Comprobante autorizado - CAE: {result.CAE}")
                return {
                    'cae': result.CAE,
                    'vto_cae': datetime.strptime(result.CAEFchVto, '%Y%m%d').date(),
                    'estado': 'autorizada'
                }
            else:
                print(f"‚ùå Comprobante rechazado")
                return {
                    'cae': None,
                    'vto_cae': None,
                    'estado': 'rechazada'
                }
                
        except Exception as e:
            print(f"‚ùå Error autorizando comprobante: {e}")
            raise Exception(f"Error al autorizar comprobante: {e}")


arca_client = ARCAClient()

# Rutas de la aplicaci√≥n
@app.route('/')
def index():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    return render_template('dashboard.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        usuario = Usuario.query.filter_by(username=username, activo=True).first()
        
        # Login simple sin encriptaci√≥n
        if usuario and usuario.password_hash == password:
            session['user_id'] = usuario.id
            session['username'] = usuario.username
            session['nombre'] = usuario.nombre
            return redirect(url_for('index'))
        else:
            flash('Usuario o contrase√±a incorrectos')
    
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

@app.route('/productos')
def productos():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    productos = Producto.query.filter_by(activo=True).all()
    return render_template('productos.html', productos=productos)

@app.route('/clientes')
def clientes():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    clientes = Cliente.query.all()
    return render_template('clientes.html', clientes=clientes)

@app.route('/nueva_venta')
def nueva_venta():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    productos = Producto.query.filter_by(activo=True).all()
    clientes = Cliente.query.all()
    return render_template('nueva_venta.html', productos=productos, clientes=clientes)

# APIs para b√∫squeda de productos
@app.route('/api/buscar_productos/<termino>')
def buscar_productos(termino):
    """Busca productos por c√≥digo o nombre (b√∫squeda parcial)"""
    if not termino or len(termino) < 2:
        return jsonify([])
    
    # B√∫squeda por c√≥digo exacto primero
    producto_exacto = Producto.query.filter_by(codigo=termino.upper(), activo=True).first()
    if producto_exacto:
        return jsonify([{
            'id': producto_exacto.id,
            'codigo': producto_exacto.codigo,
            'nombre': producto_exacto.nombre,
            'precio': float(producto_exacto.precio),
            'stock': producto_exacto.stock,
            'iva': float(producto_exacto.iva),
            'match_tipo': 'codigo_exacto',
            'descripcion': producto_exacto.descripcion or ''
        }])
    
    # B√∫squeda parcial en c√≥digo y nombre
    termino_busqueda = f"%{termino.lower()}%"
    
    productos = Producto.query.filter(
        and_(
            Producto.activo == True,
            or_(
                Producto.codigo.ilike(termino_busqueda),
                Producto.nombre.ilike(termino_busqueda),
                Producto.descripcion.ilike(termino_busqueda)
            )
        )
    ).limit(10).all()
    
    resultados = []
    for producto in productos:
        # Determinar tipo de coincidencia para ordenar resultados
        match_tipo = 'nombre'
        if termino.lower() in producto.codigo.lower():
            match_tipo = 'codigo'
        elif termino.lower() in producto.nombre.lower()[:20]:
            match_tipo = 'nombre_inicio'
        
        resultados.append({
            'id': producto.id,
            'codigo': producto.codigo,
            'nombre': producto.nombre,
            'precio': float(producto.precio),
            'stock': producto.stock,
            'iva': float(producto.iva),
            'match_tipo': match_tipo,
            'descripcion': producto.descripcion or ''
        })
    
    # Ordenar resultados por relevancia
    def orden_relevancia(item):
        if item['match_tipo'] == 'codigo_exacto':
            return 0
        elif item['match_tipo'] == 'codigo':
            return 1
        elif item['match_tipo'] == 'nombre_inicio':
            return 2
        else:
            return 3
    
    resultados.sort(key=orden_relevancia)
    return jsonify(resultados)

@app.route('/api/producto_por_id/<int:producto_id>')
def get_producto_por_id(producto_id):
    """Obtiene un producto por ID"""
    producto = Producto.query.filter_by(id=producto_id, activo=True).first()
    if producto:
        return jsonify({
            'id': producto.id,
            'codigo': producto.codigo,
            'nombre': producto.nombre,
            'precio': float(producto.precio),
            'stock': producto.stock,
            'iva': float(producto.iva),
            'descripcion': producto.descripcion or ''
        })
    return jsonify({'error': 'Producto no encontrado'}), 404

@app.route('/api/producto/<codigo>')
def get_producto(codigo):
    """Obtiene un producto por c√≥digo exacto"""
    producto = Producto.query.filter_by(codigo=codigo.upper(), activo=True).first()
    if producto:
        return jsonify({
            'id': producto.id,
            'codigo': producto.codigo,
            'nombre': producto.nombre,
            'precio': float(producto.precio),
            'stock': producto.stock,
            'iva': float(producto.iva),
            'descripcion': producto.descripcion or ''
        })
    return jsonify({'error': 'Producto no encontrado'}), 404

# REEMPLAZAR la funci√≥n procesar_venta en app.py por esta versi√≥n corregida:

@app.route('/procesar_venta', methods=['POST'])
def procesar_venta():
    if 'user_id' not in session:
        return jsonify({'error': 'No autorizado'}), 401
    
    try:
        data = request.json
        
        # PASO 1: Obtener pr√≥ximo n√∫mero de comprobante ANTES de crear la factura
        try:
            print("Intentando obtener n√∫mero de AFIP...")
            ultimo_numero = arca_client.get_ultimo_comprobante(int(data.get('tipo_comprobante', '11')))
            nuevo_numero = ultimo_numero + 1
            print(f"N√∫mero obtenido de AFIP: {nuevo_numero}")
        except Exception as e:
            print(f"Error al obtener n√∫mero de AFIP: {e}")
            print("Usando numeraci√≥n local...")
            
            # Fallback: usar numeraci√≥n local
            ultima_factura = Factura.query.filter_by(
                tipo_comprobante=data.get('tipo_comprobante', '11'),
                punto_venta=ARCA_CONFIG.PUNTO_VENTA
            ).order_by(Factura.id.desc()).first()
            
            if ultima_factura and ultima_factura.numero:
                try:
                    # Extraer n√∫mero de la √∫ltima factura (formato: 0001-00000001)
                    ultimo_numero_local = int(ultima_factura.numero.split('-')[1])
                    nuevo_numero = ultimo_numero_local + 1
                except:
                    nuevo_numero = 1
            else:
                nuevo_numero = 1
            
            print(f"N√∫mero local generado: {nuevo_numero}")
        
        # PASO 2: Generar n√∫mero de factura con formato correcto
        numero_factura = f"{ARCA_CONFIG.PUNTO_VENTA:04d}-{nuevo_numero:08d}"
        print(f"N√∫mero de factura generado: {numero_factura}")
        
        # PASO 3: Crear factura CON el n√∫mero ya asignado
        factura = Factura(
            numero=numero_factura,  # ‚Üê ASIGNAR AQU√ç EL N√öMERO
            tipo_comprobante=data.get('tipo_comprobante', '11'),
            punto_venta=ARCA_CONFIG.PUNTO_VENTA,
            cliente_id=data['cliente_id'],
            usuario_id=session['user_id'],
            subtotal=Decimal(str(data['subtotal'])),
            iva=Decimal(str(data['iva'])),
            total=Decimal(str(data['total']))
        )
        
        db.session.add(factura)
        db.session.flush()  # Para obtener el ID sin hacer commit
        
        print(f"Factura creada con ID: {factura.id} y n√∫mero: {factura.numero}")
        
        # PASO 4: Agregar detalles
        for item in data['items']:
            detalle = DetalleFactura(
                factura_id=factura.id,
                producto_id=item['producto_id'],
                cantidad=item['cantidad'],
                precio_unitario=Decimal(str(item['precio_unitario'])),
                subtotal=Decimal(str(item['subtotal']))
            )
            db.session.add(detalle)
            
            # Actualizar stock
            producto = Producto.query.get(item['producto_id'])
            if producto:
                producto.stock -= item['cantidad']
                print(f"Stock actualizado para {producto.nombre}: {producto.stock}")
        
        # PASO 5: Intentar autorizar en AFIP
        try:
            print("Intentando autorizar en AFIP...")
            cliente = Cliente.query.get(data['cliente_id'])
            factura_data = {
                'tipo_comprobante': int(data.get('tipo_comprobante', '11')),
                'numero': nuevo_numero,
                'fecha': factura.fecha,
                'cliente_cuit': cliente.documento if cliente and cliente.tipo_documento == 'CUIT' else '0',
                'subtotal': factura.subtotal,
                'iva': factura.iva,
                'total': factura.total
            }
            
            resultado_afip = arca_client.autorizar_comprobante(factura_data)
            
            factura.cae = resultado_afip['cae']
            factura.vto_cae = resultado_afip['vto_cae']
            factura.estado = resultado_afip['estado']
            
            print(f"Autorizaci√≥n AFIP exitosa. CAE: {factura.cae}")
            
        except Exception as e:
            print(f"Error al autorizar en AFIP: {e}")
            factura.estado = 'error_afip'
            # Continuar con la venta local
        
        # PASO 6: Guardar todo en la base de datos
        db.session.commit()
        
        print(f"Venta procesada exitosamente: {factura.numero}")
        
        return jsonify({
            'success': True,
            'factura_id': factura.id,
            'numero': factura.numero,
            'cae': factura.cae,
            'estado': factura.estado
        })
        
    except Exception as e:
        print(f"Error en procesar_venta: {str(e)}")
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/facturas')
def facturas():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    facturas = Factura.query.order_by(Factura.fecha.desc()).limit(100).all()
    return render_template('facturas.html', facturas=facturas)

@app.route('/factura/<int:factura_id>')
def ver_factura(factura_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    factura = Factura.query.get_or_404(factura_id)
    return render_template('factura_detalle.html', factura=factura)

# Funciones de inicializaci√≥n
def create_tables():
    """Crea las tablas de la base de datos"""
    try:
        db.create_all()
        
        # Crear usuario admin por defecto si no existe
        if not Usuario.query.filter_by(username='admin').first():
            admin = Usuario(
                username='admin',
                password_hash='admin123',  # Sin encriptaci√≥n para simplicidad
                nombre='Administrador',
                rol='admin'
            )
            db.session.add(admin)
            db.session.commit()
            print("‚úÖ Usuario admin creado (admin/admin123)")
        
        print("‚úÖ Base de datos inicializada correctamente")
        
    except Exception as e:
        print(f"‚ùå Error al inicializar base de datos: {e}")

if __name__ == '__main__':
    # Crear directorios necesarios
    os.makedirs('cache', exist_ok=True)
    os.makedirs('logs', exist_ok=True)
    os.makedirs('certificados', exist_ok=True)
    
    print("üöÄ Iniciando POS Argentina...")
    print(f"üìç URL: http://localhost:5000")
    print(f"üè¢ CUIT: {ARCA_CONFIG.CUIT}")
    print(f"üè™ Punto de Venta: {ARCA_CONFIG.PUNTO_VENTA}")
    print(f"üîß Ambiente: {'HOMOLOGACI√ìN' if ARCA_CONFIG.USE_HOMOLOGACION else 'PRODUCCI√ìN'}")
    print(f"üë§ Usuario: admin")
    print(f"üîë Contrase√±a: admin123")
    print()
    
    with app.app_context():
        create_tables()
    
    app.run(debug=True, host='0.0.0.0', port=5000)